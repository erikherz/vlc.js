From 75e1e9da12cf1ef62a3bb9d0d09bd13b6f73e0c4 Mon Sep 17 00:00:00 2001
From: Mehdi Sabwat <mehdi@videolabs.io>
Date: Fri, 30 Apr 2021 01:15:17 +0200
Subject: [PATCH 14/16] aout: add emscripten audio worklet module

---
 modules/audio_output/Makefile.am    |   5 +
 modules/audio_output/emscripten.cpp | 405 ++++++++++++++++++++++++++++
 2 files changed, 410 insertions(+)
 create mode 100644 modules/audio_output/emscripten.cpp

diff --git a/modules/audio_output/Makefile.am b/modules/audio_output/Makefile.am
index 194c421e54..7c87faaea8 100644
--- a/modules/audio_output/Makefile.am
+++ b/modules/audio_output/Makefile.am
@@ -117,3 +117,8 @@ endif
 if HAVE_TVOS
 aout_LTLIBRARIES += libaudiounit_ios_plugin.la
 endif
+
+libemworklet_audio_plugin_la_SOURCES = audio_output/emscripten.cpp
+if HAVE_EMSCRIPTEN
+aout_LTLIBRARIES += libemworklet_audio_plugin.la
+endif
diff --git a/modules/audio_output/emscripten.cpp b/modules/audio_output/emscripten.cpp
new file mode 100644
index 0000000000..1c890b3f6d
--- /dev/null
+++ b/modules/audio_output/emscripten.cpp
@@ -0,0 +1,405 @@
+/*****************************************************************************
+ * emscripten.c: audio output module using audio worklets
+ *****************************************************************************
+ * Copyright Â© 2020 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <assert.h>
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_aout.h>
+
+#include <emscripten.h>
+#include <emscripten/val.h>
+#include <emscripten/bind.h>
+#include <emscripten/html5.h>
+
+#include <cstdint>
+#include <stdlib.h>
+
+#define STORAGE_SIZE 1024 * 1024
+// Sample rate might change, and it would be good to be able to change it during playback.
+#define AUDIO_WORKLET_SAMPLE_RATE 44100
+// Don't know any way to get the browser's supported number of channels.
+#define AUDIO_WORKLET_NB_CHANNELS 2
+
+using namespace emscripten;
+namespace {	   
+	EM_BOOL requestAnimationFrame_cb( double time, void *userData );
+
+	class AWNodeWrapper {
+	public:
+		val context = val::undefined();
+		val getCtx() const { return context; };
+		void setCtx(val v_context) { context = v_context; };
+		
+		uintptr_t sab_ptr;
+		uintptr_t getSabPtr() const { return sab_ptr; };
+		void setSabPtr(uintptr_t p_sab) { sab_ptr = p_sab; };
+		
+		size_t sab_size;
+		size_t getSabSize() const { return sab_size; };
+		void setSabSize(size_t s_size) { sab_size = s_size; };
+		
+		int8_t channels;
+		int8_t getChannels() const { return channels; };
+		void setChannels(int8_t chan) { channels = chan; };
+		
+		AWNodeWrapper(int sample_rate) {
+			// Prepare audio context options
+			val audio_ctx_options = val::object();
+			audio_ctx_options.set("sampleRate", sample_rate);
+			
+			context = val::global("AudioContext").new_(audio_ctx_options);
+			context.call<void>("suspend");
+		}
+		
+		val operator()( val undefined_promise_argument ) {
+			(val)undefined_promise_argument;
+			
+			// Prepare AWN Options
+			val awn_options = val::object();
+			val awn_opt_outputChannelCount = val::array();
+			awn_opt_outputChannelCount.call<val>("push", channels);
+			awn_options.set("outputChannelCount", awn_opt_outputChannelCount);
+			awn_options.set("numberOfInputs", 0);
+			awn_options.set("numberOfOutputs", 1);
+			
+			val AudioNode = val::global("AudioWorkletNode").new_(context, std::string("worklet-processor"), awn_options);
+			AudioNode.set("channelCount", channels);
+			
+			//Prepare postMessage message
+			val msg = val::object();
+			msg.set("type", std::string("recv-audio-queue"));
+			msg.set("data", val::module_property("wasmMemory")["buffer"]);
+			msg.set("sab_ptr", sab_ptr);
+			msg.set("sab_size", sab_size);
+			
+			AudioNode["port"].call<val>("postMessage", msg);
+			AudioNode.call<val>("connect", context["destination"]);
+			
+			emscripten_request_animation_frame_loop(requestAnimationFrame_cb, this);
+			
+			return val::undefined();
+		}
+	};
+	
+	EMSCRIPTEN_BINDINGS(AWWSCOPE) {
+		class_<AWNodeWrapper>("awn_cb_wrapper")
+			.constructor<int>()
+			.property("context", &AWNodeWrapper::getCtx, &AWNodeWrapper::setCtx)
+			.property("sab_ptr", &AWNodeWrapper::getSabPtr, &AWNodeWrapper::setSabPtr)
+			.property("sab_size", &AWNodeWrapper::getSabSize, &AWNodeWrapper::setSabSize)
+			.property("channels", &AWNodeWrapper::getChannels, &AWNodeWrapper::setChannels)
+			.function("awn_call", &AWNodeWrapper::operator());
+	};
+	
+	typedef struct aout_sys_t
+	{
+		int8_t *sab;
+		size_t sab_size;
+		AWNodeWrapper *awn_inst;
+		float volume;
+		
+	} aout_sys_t;
+
+	EM_BOOL requestAnimationFrame_cb( double time, void *userData ) {
+		(double) time;
+		AWNodeWrapper *inst = reinterpret_cast<AWNodeWrapper *>(userData);
+		uint32_t *sab = reinterpret_cast<uint32_t *>(inst->getSabPtr());
+		val view = val(typed_memory_view(inst->getSabSize(), sab));
+		val context = inst->getCtx();
+		if ( view[0].as<int>() == 1 ) {
+			context.call<val>("resume");
+			sab[0] = 0;
+			return EM_FALSE;
+		}
+		return EM_TRUE;
+	}
+	
+	// For Atomics.store() and .load() only integer types are supported
+	unsigned int js_index_load(int8_t *sab_ptr, int8_t index, size_t sab_size){
+		uint32_t *buffer_view = reinterpret_cast<uint32_t *>(sab_ptr); 
+		val buffer = val(typed_memory_view(sab_size, buffer_view));
+		
+		return val::global("Atomics").call<unsigned int>("load", buffer, index);
+	}
+	
+	void js_index_store(int8_t *sab_ptr, int8_t index, unsigned int value, size_t sab_size) {
+		uint32_t *buffer_view = reinterpret_cast<uint32_t *>(sab_ptr); 
+		val buffer = val(typed_memory_view(sab_size, buffer_view));
+		
+		return val::global("Atomics").call<void>("store", buffer, index, value);
+	}
+
+	// careful when calling this, you cannot wait on any index
+	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait
+	unsigned int js_index_wait(int8_t *sab_ptr, int8_t index, size_t sab_size) {
+		int32_t *buffer_view = reinterpret_cast<int32_t *>(sab_ptr); 
+		val buffer = val(typed_memory_view(sab_size, buffer_view));
+
+		return val::global("Atomics").call<unsigned int>("wait", buffer, index);
+	}
+
+	void Flush( audio_output_t *aout )
+	{
+		aout_sys_t * sys = reinterpret_cast<aout_sys_t *>(aout->sys);
+		bzero(sys->sab, sys->sab_size);
+	}
+	
+	int Start( audio_output_t *aout, audio_sample_format_t *restrict fmt )
+	{
+		aout_sys_t *sys = reinterpret_cast<aout_sys_t *>(aout->sys);
+		unsigned nbChannels = aout_FormatNbChannels(fmt);
+
+		if (( nbChannels == 0 ) || !AOUT_FMT_LINEAR(fmt))
+			return VLC_EGENERIC;
+		fmt->i_format = VLC_CODEC_FL32;
+		fmt->i_channels = AUDIO_WORKLET_NB_CHANNELS;
+		fmt->i_rate = AUDIO_WORKLET_SAMPLE_RATE;
+
+		// resume audio context (first start, it is paused when initialized)
+		js_index_store(sys->sab, 4, (int)sys->volume * 100, sys->sab_size);
+		js_index_store(sys->sab, 0, 1, sys->sab_size);
+
+		return VLC_SUCCESS;
+	}
+
+	void Stop (audio_output_t *aout)
+	{
+		Flush(aout);
+	}
+	
+	int audio_worklet_push (audio_output_t *aout, const int8_t *data, unsigned data_size) {
+		aout_sys_t *sys = reinterpret_cast<aout_sys_t *>(aout->sys);
+		int8_t *sab_view = sys->sab + 5 * sizeof(int32_t);
+		unsigned head = js_index_load(sys->sab, 1, sys->sab_size);
+
+		// TODO: check that we do not write on unconsumed data.
+		if (head + data_size > STORAGE_SIZE) {
+			// Copy the part of the data at the buffer end
+			unsigned data_size_copy_end = STORAGE_SIZE - head;
+			memcpy(sab_view + head, data, data_size_copy_end);
+			head = 0;
+			
+			// Copy the part of the data at the buffer start
+			unsigned data_size_copy_start = data_size - data_size_copy_end;
+			memcpy(sab_view + head, data, data_size_copy_start);
+			head = data_size_copy_start;
+		}
+		else {
+			memcpy(sab_view + head, data, data_size);
+			head += data_size;
+		}
+		js_index_store(sys->sab, 1, head, sys->sab_size);
+		return 0;  // return success to indicate successful push.
+	}
+
+	void Play( audio_output_t *aout, block_t *block, vlc_tick_t date)
+	{
+		VLC_UNUSED(date);
+		aout_sys_t *sys = reinterpret_cast<aout_sys_t *>(aout->sys);
+		const int8_t* data = (int8_t *)block->p_buffer;
+		size_t data_size = block->i_buffer;
+		
+		unsigned head = js_index_load(sys->sab, 1, sys->sab_size);
+		unsigned tail = js_index_load(sys->sab, 2, sys->sab_size);
+		unsigned new_head = (head + data_size) % STORAGE_SIZE;
+		if (new_head > tail)
+		{
+			// the worklet processor keeps rendering  until tail matches head
+			// it will be notified by an Atomics.notify() from the process() callback
+			js_index_wait(sys->sab, 3, sys->sab_size);
+		}
+		audio_worklet_push(aout, data, data_size);
+		block_Release(block);
+	}
+	
+	void Pause( audio_output_t *aout, bool paused, vlc_tick_t date )
+	{
+		aout_sys_t * sys = reinterpret_cast<aout_sys_t *>(aout->sys);
+		if (paused == false) {
+			js_index_store(sys->sab, 0, 0, sys->sab_size);
+		}
+		else {
+			js_index_store(sys->sab, 0, 1, sys->sab_size);
+		}
+		VLC_UNUSED(date);
+		Flush(aout);
+	}
+	
+	int Time_Get( audio_output_t *aout, vlc_tick_t *delay)
+	{
+		return aout_TimeGetDefault(aout, delay);
+	}
+
+	void Close( vlc_object_t *obj )
+	{
+		audio_output_t *aout = (audio_output_t *)obj;
+		struct aout_sys_t *sys = reinterpret_cast<struct aout_sys_t *>(aout->sys);
+
+		delete sys->awn_inst;
+		free(sys->sab);
+		free(sys);
+	}
+
+	int Volume_Set( audio_output_t *aout, float volume)
+	{
+		struct aout_sys_t *sys = reinterpret_cast<struct aout_sys_t *>(aout->sys);
+
+		if (volume > 1.0f)
+			volume = 1.0f;
+		else if (volume < 0.0f)
+			volume = 0.0f;
+		// TODO: implement gain
+		sys->volume = volume;
+		js_index_store(sys->sab, 4, (int)volume * 100, sys->sab_size);
+		aout_VolumeReport(aout, volume);
+
+		return 0;
+	}
+
+	int Mute_Set( audio_output_t *aout, bool mute)
+	{
+		struct aout_sys_t *sys = reinterpret_cast<struct aout_sys_t *>(aout->sys);
+
+		if (mute == 0)
+			js_index_store(sys->sab, 4, 0, sys->sab_size);
+		else
+			js_index_store(sys->sab, 4, (int)sys->volume * 100, sys->sab_size);
+		aout_MuteReport(aout, mute);
+		return 0;
+	}
+
+	
+	int Open( vlc_object_t *obj )
+	{
+		audio_output_t * aout = (audio_output_t *) obj;
+		
+		/* Allocate structures */
+		aout_sys_t *sys = reinterpret_cast<aout_sys_t *>(malloc( sizeof( *sys ) ));
+		if( unlikely(sys == NULL) )
+			return VLC_ENOMEM;
+		
+		aout->sys = sys;
+		aout->start = Start;
+		aout->stop = Stop;
+		aout->play = Play;
+		aout->pause = Pause;
+		aout->flush = Flush;
+		aout->time_get = Time_Get;
+		aout->volume_set = Volume_Set;
+		aout->mute_set = Mute_Set;
+		
+		sys->awn_inst = new AWNodeWrapper(AUDIO_WORKLET_SAMPLE_RATE);
+		sys->sab_size = 5 * sizeof(int32_t) + STORAGE_SIZE;
+		sys->sab = reinterpret_cast<int8_t *>(malloc( sys->sab_size ));
+		sys->volume = 1.0f;
+
+		if ( unlikely(sys->sab == NULL) )
+			return VLC_ENOMEM;
+		bzero(sys->sab, sys->sab_size);
+		
+		val webaudio_context = sys->awn_inst->getCtx();
+		
+		// Prepare audioWorkletProcessor blob
+		val document = val::global("document");
+		val script = document.call<val>("createElement", std::string("SCRIPT"));
+		script.set("type", std::string("worklet"));
+		std::string processorStr = "class Processor extends AudioWorkletProcessor { \
+	constructor() { \
+		super(); \
+		this.port.onmessage = e => { \
+			if (e.data.type === 'recv-audio-queue') { \
+				this.buf = e.data.data; \
+				this.capacity = e.data.sab_size / 4; \
+				this.flag = new Uint32Array(this.buf, e.data.sab_ptr, 1); \
+				this.head = new Uint32Array(this.buf, e.data.sab_ptr + 4, 1); \
+				this.tail = new Uint32Array(this.buf, e.data.sab_ptr + 8, 1); \
+				this.can_write = new Int32Array(this.buf, e.data.sab_ptr + 12, 1); \
+				this.volume = new Int32Array(this.buf, e.data.sab_ptr + 16, 1); \
+				this.storage = new Float32Array(this.buf, e.data.sab_ptr + 20, this.capacity); \
+			} else { \
+				throw 'unexpected.'; \
+			} \
+		}; \
+	} \
+	process(inputs, outputs, parameters) { \
+		const output = outputs[0]; \
+		const nbChannels = output.length; \
+		const nbSamples = output[0].length; \
+		if (this.head.buffer.byteLength == 0) { \
+			throw new Error('wasmMemory grew'); \
+		} \
+		var head = Atomics.load(this.head, 0) / 4; \
+		var tail = Atomics.load(this.tail, 0) / 4; \
+		var i = 0; \
+		var volume = (Atomics.load(this.volume, 0) / 4) / 100; \
+		while (tail != head && i < nbSamples) \
+		{ \
+			for (let c = 0; c < nbChannels; ++c) { \
+				output[c][i] = this.storage[tail] * volume; \
+				tail++; \
+				if (tail == this.capacity) { \
+					tail = 0; \
+				} \
+			} \
+			i++; \
+		} \
+		Atomics.store(this.tail, 0, tail * 4); \
+		Atomics.notify(this.can_write, 0); \
+		return true; \
+	} \
+} \
+registerProcessor('worklet-processor', Processor);";
+		script.set("innerText", processorStr);
+		val ProcessorTextArray = val::array();
+		ProcessorTextArray.call<val>("push", script["innerText"]);
+		val BlobObject = val::object();
+		BlobObject.set("type", std::string("application/javascript"));
+		val WorkletModuleUrl = val::global("URL").call<val>("createObjectURL", val::global("Blob").new_(ProcessorTextArray, BlobObject));
+		
+		// Prepare audioWorkletProcessor callback
+		val cb_caller = val::module_property("awn_cb_wrapper").new_(AUDIO_WORKLET_SAMPLE_RATE);
+		cb_caller.set("context", val(webaudio_context));
+		cb_caller.set("sab_ptr", val(reinterpret_cast<uintptr_t>(sys->sab)));
+		cb_caller.set("sab_size", val(sys->sab_size));
+		cb_caller.set("channels", val(AUDIO_WORKLET_NB_CHANNELS));
+		val awn_caller = cb_caller["awn_call"];
+		val awn_cb = awn_caller.call<val>("bind", cb_caller);
+		
+		// start audio worklet (since the context is suspended, sound won't start now
+		// Since the WebAudio Context cannot be created in a worker, we create
+		// it in the main_thread and use the SAB to signal it when we want it to start
+		webaudio_context["audioWorklet"].call<val>("addModule", WorkletModuleUrl).call<val>("then", awn_cb);
+
+		return VLC_SUCCESS;
+	}
+}
+
+vlc_module_begin ()
+	set_description( N_("Emscripten Worklet audio output") )
+	set_shortname( "emworklet" )
+	set_capability( "audio output", 100 )
+	set_category( CAT_AUDIO )
+	set_subcategory( SUBCAT_AUDIO_AOUT )
+	set_callbacks( Open, Close )
+vlc_module_end ()
-- 
2.31.1

