From 41b4a0210077f0e9c677b94823a5d7c070fb08ab Mon Sep 17 00:00:00 2001
From: metehan-arslan <99metehanarslan@gmail.com>
Date: Fri, 26 Aug 2022 22:50:21 +0300
Subject: [PATCH] fix jitter in flac playback

---
 modules/audio_output/emscripten.cpp | 51 +++++++++++++++++++++--------
 1 file changed, 37 insertions(+), 14 deletions(-)

diff --git a/modules/audio_output/emscripten.cpp b/modules/audio_output/emscripten.cpp
index a7e9fb0d4d..de442e2b73 100644
--- a/modules/audio_output/emscripten.cpp
+++ b/modules/audio_output/emscripten.cpp
@@ -40,8 +40,7 @@
 #define STORAGE_SIZE 1024 * 1024
 // Sample rate might change, and it would be good to be able to change it during playback.
 #define AUDIO_WORKLET_SAMPLE_RATE 44100
-// Don't know any way to get the browser's supported number of channels.
-#define AUDIO_WORKLET_NB_CHANNELS 2
+
 
 using namespace emscripten;
 namespace {
@@ -70,11 +69,11 @@ namespace {
 		uintptr_t getSabPtr() const { return sab_ptr; };
 		void setSabPtr(uintptr_t p_sab) { sab_ptr = p_sab; };
 
-		int8_t channels;
-		int8_t getChannels() const { return channels; };
+		unsigned channels;
+		unsigned getChannels() const { return channels; };
 		void setChannels(int8_t chan) { channels = chan; };
 
-		AWNodeWrapper(int sample_rate) {
+		AWNodeWrapper(unsigned long sample_rate) {
 			// Prepare audio context options
 			val audio_ctx_options = val::object();
 			audio_ctx_options.set("sampleRate", sample_rate);
@@ -146,7 +145,10 @@ namespace {
 	{
 		sound_buffer_t *sab; // TODO - rename to sound_buff
 		AWNodeWrapper *awn_inst;
-
+		
+		// let's see if it changes channels to 2 and samplerate to 44100;
+	    unsigned i_channelCount = 0;
+        unsigned long i_sampleRate = 48000;
 	} aout_sys_t;
 
 	EM_BOOL requestAnimationFrame_cb( double time, void *userData ) {
@@ -177,7 +179,7 @@ namespace {
 	void Flush( audio_output_t *aout )
 	{
 		aout_sys_t * sys = reinterpret_cast<aout_sys_t *>(aout->sys);
-		bzero(&sys->sab->storage, sizeof(sys->sab->storage));
+		memset(&sys->sab->storage, 0, sizeof(sys->sab->storage));
 	}
 
 	int Start( audio_output_t *aout, audio_sample_format_t *restrict fmt )
@@ -188,8 +190,8 @@ namespace {
 		if (( nbChannels == 0 ) || !AOUT_FMT_LINEAR(fmt))
 			return VLC_EGENERIC;
 		fmt->i_format = VLC_CODEC_FL32;
-		fmt->i_channels = AUDIO_WORKLET_NB_CHANNELS;
-		fmt->i_rate = AUDIO_WORKLET_SAMPLE_RATE;
+		fmt->i_channels = sys->i_channelCount;
+		fmt->i_rate = sys->i_sampleRate;
 
 		// resume audio context (first start, it is paused when initialized)
 		sys->sab->is_paused.store(1);
@@ -216,7 +218,7 @@ namespace {
 
 			// Copy the part of the data at the buffer start
 			unsigned data_size_copy_start = data_size - data_size_copy_end;
-			memcpy(sab_view + head, data, data_size_copy_start);
+			memcpy(sab_view + head, data + data_size_copy_end, data_size_copy_start);
 			head = data_size_copy_start;
 		}
 		else {
@@ -324,17 +326,38 @@ namespace {
 		aout->time_get = Time_Get;
 		aout->volume_set = Volume_Set;
 		aout->mute_set = Mute_Set;
-
+		
+        // Audio output is breaking when we implement i_sampleRate in here.
 		sys->awn_inst = new AWNodeWrapper(AUDIO_WORKLET_SAMPLE_RATE);
 		sys->sab = (sound_buffer_t*)malloc(sizeof(sound_buffer_t));
 
 		if ( unlikely(sys->sab == NULL) )
 			return VLC_ENOMEM;
-		bzero(sys->sab, sizeof(sound_buffer_t));
+		memset(sys->sab, 0, sizeof(sound_buffer_t));
 		sys->sab->volume = 100;
 
 		val webaudio_context = sys->awn_inst->getCtx();
 
+        //These EM_ASM values needs to be re-written with Emval. (WiP)
+        EM_ASM(
+        let actx = new AudioContext();
+        console.log("maxChannelCount: " + actx.destination.maxChannelCount);
+        );
+
+        sys->i_channelCount = EM_ASM_INT(
+        let actx = new AudioContext();
+        console.log("channelCount: " + actx.destination.channelCount);
+        return actx.destination.maxChannelCount;
+        );
+        msg_Info(aout, "i_channelCount: %d", sys->i_channelCount);
+
+        sys->i_sampleRate = EM_ASM_INT(
+        let actx = new AudioContext();
+        console.log("sampleRate: " + actx.destination.context.sampleRate );
+        return actx.destination.context.sampleRate;
+        );
+        msg_Info(aout, "i_sampleRate: %lu", sys->i_sampleRate);
+
 		// Prepare audioWorkletProcessor blob
 		val document = val::global("document");
 		val script = document.call<val>("createElement", std::string("SCRIPT"));
@@ -396,10 +419,10 @@ registerProcessor('worklet-processor', Processor);";
 		val WorkletModuleUrl = val::global("URL").call<val>("createObjectURL", val::global("Blob").new_(ProcessorTextArray, BlobObject));
 
 		// Prepare audioWorkletProcessor callback
-		val cb_caller = val::module_property("awn_cb_wrapper").new_(AUDIO_WORKLET_SAMPLE_RATE);
+		val cb_caller = val::module_property("awn_cb_wrapper").new_(sys->i_sampleRate);
 		cb_caller.set("context", val(webaudio_context));
 		cb_caller.set("sab_ptr", val(reinterpret_cast<uintptr_t>(sys->sab)));
-		cb_caller.set("channels", val(AUDIO_WORKLET_NB_CHANNELS));
+		cb_caller.set("channels", val(sys->i_channelCount));
 		val awn_caller = cb_caller["awn_call"];
 		val awn_cb = awn_caller.call<val>("bind", cb_caller);
 
-- 
2.37.2

