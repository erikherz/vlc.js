From 215d7824e6513027e048a8b23837759bd5081777 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Hugo=20Beauz=C3=A9e-Luyssen?= <hugo@beauzee.fr>
Date: Tue, 10 May 2022 08:16:38 +0200
Subject: [PATCH 39/63] WIP webcodec remove manual block queue

---
 modules/codec/webcodec.cpp | 147 ++++++++++++++++++++++++-------------
 1 file changed, 97 insertions(+), 50 deletions(-)

diff --git a/modules/codec/webcodec.cpp b/modules/codec/webcodec.cpp
index d357e15a91..631d04f214 100644
--- a/modules/codec/webcodec.cpp
+++ b/modules/codec/webcodec.cpp
@@ -47,10 +47,6 @@ using emval = emscripten::val;
 
 struct decoder_sys_t
 {
-    emval decoder = emval::undefined();
-    std::queue<block_t*> blocks;
-    vlc::threads::mutex mutex;
-    vlc::threads::condition_variable cond;
     vlc_thread_t th;
 
     vlc_video_context* vctx;
@@ -81,11 +77,23 @@ EMSCRIPTEN_KEEPALIVE int32_t queuePicture(void* ctx, picture_t* pic, int64_t tim
 {
     auto dec = static_cast<decoder_t*>(ctx);
     pic->date = VLC_TICK_FROM_US(timestamp);
+    msg_Dbg(dec, "Picture timestamp: %" PRId64 "\n", timestamp);
     pic->b_progressive = true;
     decoder_QueueVideo(dec, pic);
     return PictureContextPrivate(pic->context)->pictureIdx;
 }
 
+EMSCRIPTEN_KEEPALIVE pthread_t getVlcDecoderWorkerThread(decoder_t* dec)
+{
+    auto sys = static_cast<decoder_sys_t*>( dec->p_sys );
+    return sys->th.handle;
+}
+
+EMSCRIPTEN_KEEPALIVE void releaseBlock( block_t* block )
+{
+    block_Release( block );
+}
+
 }
 
 EM_ASYNC_JS(bool, probeConfig, (emscripten::EM_VAL cfg), {
@@ -165,7 +173,7 @@ static emval getDecoderConfig( decoder_t* dec, bool includeExtraData )
     return decoderConfig;
 }
 
-EM_JS(emscripten::EM_VAL, initDecoderJS, (void* decoder), {
+EM_JS(emscripten::EM_VAL, initDecoderJS, (void* decoder, emscripten::EM_VAL decCfgHandle), {
     function onInteropMessage(msg) {
         let data = msg['data'];
         if (data['customCmd'] == 'sendFrame') {
@@ -197,6 +205,18 @@ EM_JS(emscripten::EM_VAL, initDecoderJS, (void* decoder), {
         await p;
     }
 
+    function onDecoderWorkerMessage(msg) {
+        const data = msg['data'];
+        if (data['customCmd'] == 'decode') {
+            Module.decoder.decode( data['chunk'] );
+            _releaseBlock( data['block'] );
+        } else if ( data['customCmd'] == 'flush' ) {
+            Module.decoder.flush();
+        } else if ( data['customCmd'] == 'close' ) {
+            Module.decoder.close();
+        }
+    }
+
     async function getPictureAsync(dec) {
         function getPicture(dec, resolve) {
             let pic = _tryGetPictureFromPool(dec);
@@ -214,6 +234,25 @@ EM_JS(emscripten::EM_VAL, initDecoderJS, (void* decoder), {
         return await p;
     }
 
+    self.addEventListener('message', (e) => {
+        let msg = e['data'];
+
+        console.log('Received message in decoder worker');
+        console.dir(msg);
+
+        if (msg['customCmd'] == 'getDecoderWorkerMessagePort') {
+            Module.msgChannel = new MessageChannel();
+            Module.msgChannel.port1.onmessage = function(msg) {
+                onDecoderWorkerMessage(msg);
+            };
+            self.postMessage({
+                customCmd: 'transferMessagePort',
+                targetThread: msg['replyTo'],
+                transferList: [Module.msgChannel.port2],
+            }, [Module.msgChannel.port2]);
+        }
+    });
+
     /* Store a handle to our decoder_t for later invocations */
     Module.webCodecCtx = decoder;
 
@@ -250,46 +289,21 @@ EM_JS(emscripten::EM_VAL, initDecoderJS, (void* decoder), {
             console.log(err);
         }
     };
-    return Emval.toHandle( new VideoDecoder( initCfg ) );
+    Module.decoder = new VideoDecoder( initCfg );
+    let decCfg = Emval.toValue( decCfgHandle );
+    Module.decoder.configure( decCfg );
 });
 
 static bool initDecoder( decoder_t* dec )
 {
-    auto sys = static_cast<decoder_sys_t*>( dec->p_sys );
-
-    sys->decoder = emval::take_ownership( initDecoderJS( dec ) );
-    if ( sys->decoder.isUndefined() )
-    {
-        msg_Err( dec, "Failed to instantiate VideoDecoder" );
-        return false;
-    }
-
-    sys->decoder.call<void>( "configure", getDecoderConfig( dec, true ) );
+    auto decCfg = getDecoderConfig( dec, true );
+    initDecoderJS( dec, decCfg.as_handle() );
 
     return true;
 }
 
-static void WebcodecDecodeWorkerTick( void* arg )
+static void mainloop_tick()
 {
-    auto dec = static_cast<decoder_t*>( arg );
-    auto sys = static_cast<decoder_sys_t*>( dec->p_sys );
-    block_t* block;
-
-    vlc::threads::mutex_locker lock{ sys->mutex };
-    while ( sys->blocks.empty() == false )
-    {
-        block = sys->blocks.front();
-        sys->blocks.pop();
-
-        auto chunk = blockToEncodedVideoChunk( dec, block );
-        block_Release(block);
-        sys->decoder.call<void>( "decode", chunk );
-
-//        auto queueSize = sys->decoder["decodeQueueSize"];
-//        auto state = sys->decoder["state"];
-//        msg_Err( dec, "Decoder state: %s ; queue size: %ld",
-//          state.as<std::string>().c_str(), queueSize.as<long int>());
-    }
 }
 
 static void* WebcodecDecodeWorker( void* arg )
@@ -314,29 +328,58 @@ static void* WebcodecDecodeWorker( void* arg )
     auto vctxPrivate = static_cast<webcodec_context*>(
             vlc_video_context_GetPrivate(sys->vctx, VLC_VIDEO_CONTEXT_WEBCODEC));
     vctxPrivate->decoder_worker = pthread_self();
-    emscripten_set_main_loop_arg( &WebcodecDecodeWorkerTick, dec, 0, false );
-    /*
-     * We want our tick function to be invoked ASAP even if we'd only be blocking
-     * waiting for a new block to be queued
-     */
-    emscripten_set_main_loop_timing( EM_TIMING_SETTIMEOUT, 1 );
+    emscripten_set_main_loop(mainloop_tick, 1, true);
     return NULL;
 }
 
+EM_ASYNC_JS(void, initDecoderWorkerMessagePort, (decoder_t* dec), {
+    if (Module.decoderWorkerPort !== undefined) {
+        return;
+    }
+    let workerMessagePortPromise = new Promise((resolve, reject) => {
+        self.addEventListener('message', function(e) {
+            let msg = e['data'];
+            if (msg.customCmd == 'transferMessagePort') {
+                let port = msg['transferList'][0];
+                if (!port) {
+                    console.log('No port provided, rejecting');
+                    reject();
+                }
+                Module.decoderWorkerPort = port;
+                resolve();
+            }
+        });
+        self.postMessage({
+            customCmd: 'getDecoderWorkerMessagePort',
+            targetThread: _getVlcDecoderWorkerThread(dec),
+            replyTo: _pthread_self()
+        });
+    });
+    await workerMessagePortPromise;
+})
+
 static int Decode( decoder_t* dec, block_t* block )
 {
-    auto sys = static_cast<decoder_sys_t*>( dec->p_sys );
-    vlc::threads::mutex_locker lock{ sys->mutex };
-    sys->blocks.push( block );
-    sys->cond.signal();
+    initDecoderWorkerMessagePort(dec);
+    auto chunk = blockToEncodedVideoChunk( dec, block );
+    EM_ASM({
+        Module.decoderWorkerPort.postMessage({
+            customCmd: 'decode',
+            chunk: Emval.toValue($0),
+            block: $1
+        });
+    }, chunk.as_handle(), block);
     return VLCDEC_SUCCESS;
 }
 
 static void Flush( decoder_t* dec )
 {
-    //FIXME: Needs to be called from the decoder thread
-    auto sys = static_cast<decoder_sys_t*>( dec->p_sys );
-    sys->decoder.call<emval>("flush").await();
+    initDecoderWorkerMessagePort(dec);
+    EM_ASM({
+        Module.decoderWorkerPort.postMessage({
+            customCmd: 'flush'
+        });
+    });
 }
 
 static int Open( vlc_object_t* obj )
@@ -397,10 +440,14 @@ static int Open( vlc_object_t* obj )
 static void Close( decoder_t* dec )
 {
     auto sys = static_cast<decoder_sys_t*>( dec->p_sys );
-    sys->decoder.call<void>("close");
     auto vctx = static_cast<webcodec_context*>(
                 vlc_video_context_GetPrivate(sys->vctx, VLC_VIDEO_CONTEXT_WEBCODEC ) );
     picture_pool_Release(vctx->pool);
+    EM_ASM({
+        Module.decoderWorkerPort.postMessage({
+            customCmd: 'close'
+        });
+    });
     delete sys;
 }
 
-- 
2.43.0

